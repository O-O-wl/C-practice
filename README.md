# C-자료구조 / 알고리즘 🧐

- [자료구조](#자료구조)
- [알고리즘](#알고리즘)



<br>

## 

> 데이터를 저장하는 형태 

### 리스트 

- **가변크기**를 가지며 삽입/삭제에 용이하지만 탐색에는 비용이 비싸다.
- 링크드 리스트의 경우, 데이터를 저장하는 공간과 다음노드의 주소를 알아야하여 **한 노드당 차지하는 메모리공간이 크다.**

<br>

### 배열

- **고정크기**를 가지며, 탐색은 빠르나, 삭제시 빈 공간을 채우기위한 재정렬이 필요하다.
- **공간을 미리 할당하기에 낭비하는 공간이 존재할 수 있다.**

<br>

### 스택

- 삽입/삭제가 정해진 규칙으로만 이뤄질 수 있는 자료구조.
- **중첩된 구조**와 같이, 나중에 들어온 입력이 먼저 처리되야 먼저 들어온 입력을 처리할 수 있는 구조에 적합하다.

<br>

### 큐

- 먼저 들어온 데이터를 먼저 처리해야할 경우 사용한다.

- 일반적으로 바로 처리가 불가능하고, **입력 들어오는 속도가 처리 속도보다 빠를 경우** 들어오는 즉각 처리가 불가능해서 저장해서 **대기시키고 처리한다**.

- 버퍼가 하나의 좋은 예이다.

  <br>

###  트리

- 이름과 같이 거꾸로된 나무처럼 생긴 자료구조이다.

  - **계층적인 자료를 표현**하고, 이진 트리와 같은 자료구조는 데이터 탐색이 매우 빠르다.

  ```
       (1)							  									(2)	
        A					
        |                                    B	  
      /   \                                 / \    
     B	   C                               D   E
    / \    🍃                             🍃  🍃
   D   E
  🍃  🍃
  ```

  트리는 위와 같은 나무를 거꾸로 해놓은 모양이며 D,C,E 나무의 끝에 위치한 잎(리프노드)이다.

  또 A는 나무가 시작되는 뿌리(루트노드)이다.

  재밌는 형태인 것은 (1)나무에서 가지를 뚝 뜯어서 심으면 다시 또 작은 나무(2)의 형태를 띄게된다. 

  이로 **큰 나무가 작은 나무를 포함하는 계층과 같은 형태를 띈다**. 또 이건 단위를 작게 작게 축소하면서 연산을 하는 재귀와 같은 방법으로 쉽게 해결 할 수 도 있다.

  <br>

  - **바이너리 트리**

    - 많은 트리의 형태중 특수한 형태로 모든 노드가 자식 노드를 2개씩 가진다.

    - 바이너리 탐색 트리 같은 형태로 구현하여 빠른 데이터 탐색이 가능하다.

      <br>

  -  **트리 순회**

    >  트리를 탐색하는 방법은 여러가지다. 

    - 전위 순회

      - **루트 노드 ➡️ 왼쪽 하위트리 ➡️ 오른쪽 하위 트리**를 순회한다.

      - 예)  A -> B를 루트로하는 트리 -> C를 루트로하는 트리를 순회

        <br>

    - 중위 순회

      - **루트의 왼쪽 하위 트리 ➡️ 상위노드 ➡️ 오른쪽 하위트리** 의 순서로 순회한다.

      - 예) B를 루트로 하는 트리 ➡️ 상위노드 ➡️ C를 루트로 하는 트리

        <br>

    - 후위 순회

      - **루트의 왼쪽 하위 트리➡️ 오른쪽 하위트리 ➡️ 상위노드**  의 순서로 순회한다
      
      - 예) B를 루트로 하는 트리  ➡️ C를 루트로 하는 트리 ➡️ 상위노드

  <br>

  <br>
---
  ## 알고리즘

  >

  <br>

- #### 버블 정렬

  > 이웃한 수와 대소 비교 후 swap을 하는 방식으로 정렬
  >
  > 1번 패스당 맨 마지막 요소가 정렬되고, 아래에서 위로 보글보글 올라가는 형태의 정렬이라서 
  >
  > 버블 정렬이라는 이름이 붙음

  - 한번의 패스당 마지막 요소가 결정되어서 다음 패스에는 비교 연산이 한번씩 줄어든다
- (n-1) + (n-2) + (n-3) … 2 + 1 = ((n-1)n)/2 의 비교연산 횟수를 가진다.
  
<br>
  
- #### 삽입 정렬

  > 버블 정렬과 비슷한 비용이 든다.
  >
  > 하나의 요소를 뽑은 후 적당한 위치에 삽입하는 연산을 반복하는 형태이다.
  >
  > 버블 정렬은 정렬이 가장 뒤부터 되는 데에 비해 삽입정렬은 앞부터 된다.
  >
  > 패스중 큰 요소를 만나는 순간 바로 패스가 끝나므로, 
  >
  > 무조건 패스를 진행하는 버블정렬보다는 약간의 성능상 우위가 있다.

  - 앞에서 부터 요소를 한개뽑는다

  - 뽑은 요소의 다음 요소부터 하나씩 앞으로 미룰수 있는가 없는가를 판단한다.

  - 판단의 기준은 현재 뽑은 요소보다 작다면 한칸 앞으로 미룬다.

  - 더 이상 못 미루게 된다면 해당요소의 앞에 뽑았던 요소를 위치(삽입)시킨다

  - 뽑았던 요소의 다음 인덱스부터 같은 연산을 수행한다.

  <br>

- #### 퀵정렬

  >빠른 정렬! 
  >
  >하나의 데이터 집합은 여러개의 데이터 집합이 될 수 있고, 
  >
  >각각의 데이터 집합을 정렬한 결과를 취합하는 방식으로 정렬을 할 수 있지 않을까?
  >
  >분할 정복이라는 문제풀이방식이다.

  - 기준이 될 요소를 하나 고른다
  - 기준보다 큰 데이터를 가진 집합과 작은 데이터를 가진 집합을 나눈다.
  - 각각의 데이터 집합에 대해 위의 연산을 반복실행한다.
  
  
  - **pivot**이라는 중심을 하나 잡고 **pivot**보다 큰 수/ 작은 수 를 정렬하고 
    - 작은 수 그룹을 또 재귀적으로 같은 방식을 취한다.
  - 평균적으로 가장 좋은 성능을 낸다.
  - 이상적인 경우 **pivot**이 항상 중앙으로 설정된다면 빠르게 정렬되며, 현재 정렬의 정도에 따른 연산의 차이가 존재한다.

<br>
